;; equality by unification ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
x = x

;; context/environment stacks ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; lookup by index: (context/environment) stack @ [1 1 1...] => value
;; stack entries are of form [name value] or [name type], so that variable
;;  name is available for debugging
([_ val] |: _) @ [] => val
(_ |: tl) @ (1 |: n) => val ~|
  tl @ n => val

;; typechecking ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; typecheck non-type variable (deBruijnized to [name index])
ctx |- `*[name index]: type ~|
  ctx @ index => type

;; typecheck type variable (deBruijnized to [name index])
ctx |- `**[name index]: type ~|
  ctx @ index => type

;; typecheck non-type function (little lambda)
;; var is present only for debugging; references to it are deBruijnized
ctx |- (var: varType \ body): varType? resultType ~|
  ([var varType] |: ctx) |- body: resultType

... use of ?? is unfortunate
... it will be understood as conditional

;; typecheck type function (big lambda)
;; var is present only for debugging; references to it are deBruijnized
ctx |- (var \\ body): var?? type ~|
  ([var Type] |: ctx) |- body: type

;; typecheck non-type function application
ctx |- (fun $ arg): type ~|
  ctx |- fun: argType? type,
  ctx |- arg: argType

;; typecheck type function application
ctx |- (fun $$ arg): type ~|
  ctx |- fun: var?? funType,
  ctx |- arg / var # funType => type

;; substitution ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; substitution: ctx |- arg / var # expr => exprWhereArgReplacesVar
;; replacement is actually of variable with index zero (at outermost level)
ctx |- arg / var # expr => substExpr ~|
  ctx |- arg @ [] # expr => substExpr

;; substitution at given variable index: ctx |- arg @ index # expr => result
ctx |- arg @ index # `*[name varIndex] => result ~|
  index = varIndex
    ?? result = arg
    !! result = `*[name varIndex]
ctx |- arg @ index # `**[name varIndex] => result ~|
  index = varIndex
    ?? result = arg
    !! result = `**[name varIndex]
ctx |- arg @ index # (var: varType \ body) => (var: varType' \ body') ~|
  ctx |- arg @ index # varType => varType',
  ctx |- arg @ (1 |: index) # body => body'
ctx |- arg @ index # (var \\ body) => (var \\ body') ~|
  ctx |- arg @ (1 |: index) # body => body'
ctx |- arg @ index # (fun $ arg) => (fun' $ arg') ~|
  ctx |- arg @ index # fun => fun',
  ctx |- arg @ index # arg => arg'
ctx |- arg @ index # (fun $$ arg) => (fun' $$ arg') ~|
  ctx |- arg @ index # fun => fun',
  ctx |- arg @ index # arg => arg'

;; deBruijnizing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DeBruijnize 